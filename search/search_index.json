{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"A2Z DSA Practice","text":"<p>A personal LLD problem-solving journal \u2014 organized by topic, built for revision.</p>"},{"location":"#topics","title":"Topics","text":"Main topic Sub topics OOPS-Core Classes \u00b7 Objects \u00b7 Inheritance \u00b7 Polymorphism \u00b7 Encapsulation \u00b7 Interfaces \u00b7 Abstraction OOPS-Excercise Classes \u00b7 Objects \u00b7 Inheritance \u00b7 Polymorphism \u00b7 Encapsulation \u00b7 Interfaces \u00b7 Abstraction Class Relationships Association \u00b7 Aggregation \u00b7 Composition \u00b7 Dependency \u00b7 Realization Class Relationships Excercise Association \u00b7 Aggregation \u00b7 Composition \u00b7 Dependency \u00b7 Realization"},{"location":"classes-excercise/","title":"OOPS CORE EXCERCISE","text":""},{"location":"classes-excercise/#classes-objects","title":"classes Objects","text":"<pre><code>class BankAccount:\n    def __init__(self, account_number: str, owner_name: str):\n        # Initialize fields: account_number, owner_name, balance (starts at 0)\n        self.account_number = account_number\n        self.owner_name = owner_name\n        self.amount = 0\n    def deposit(self, amount: float) -&gt; None:\n        # Add amount to balance (only if amount is positive)\n        if amount &lt; 0:\n            return \n        self.amount += float(amount)\n\n    def withdraw(self, amount: float) -&gt; bool:\n        # Remove amount from balance if sufficient funds exist\n        # Return True if successful, False otherwise\n        if self.amount &gt;= amount:\n            self.amount -= amount\n            return True\n        return False\n\n    def get_balance(self) -&gt; float:\n        # Return the current balance\n        return self.amount\n\nclass Book:\n    def __init__(self, title: str, author: str, isbn: str):\n        # Initialize fields: title, author, isbn, is_available (starts as True)\n        self.title = title\n        self.author = author\n        self.isbn = isbn\n        self.available = True\n\n    def borrow_book(self) -&gt; bool:\n        # Mark book as unavailable if currently available\n        # Return True if successful, False if already borrowed\n        if self.available:\n            self.available = False\n            return True\n        return False\n\n    def return_book(self) -&gt; None:\n        # Mark book as available\n        self.available = True\n\n    def display_info(self) -&gt; None:\n        # Print: \"Title by Author (ISBN: isbn) - Available\" or \"- Borrowed\"\n        print(f\"{self.title} by {self.author} (ISBN: {self.isbn}) -\",'Available' if self.available else 'Borrowed')\n\n\n\ndef main():\n    account = BankAccount(\"123456\", \"John Doe\")\n    account.deposit(1000)\n    print(account.get_balance())  # Should print 1000.0\n\n    success = account.withdraw(500)\n    print(str(success).lower())   # Should print true\n    print(account.get_balance())  # Should print 500.0\n\n    success = account.withdraw(1000)\n    print(str(success).lower())   # Should print false\n\n    book = Book(\"The Pragmatic Programmer\", \"David Thomas\", \"978-0135957059\")\n    book.display_info()\n\n    success = book.borrow_book()\n    print(f\"Borrow successful: {str(success).lower()}\")\n    book.display_info()\n\n    success = book.borrow_book()\n    print(f\"Borrow successful: {str(success).lower()}\")\n\n    book.return_book()\n    book.display_info()\n\nif __name__ == \"__main__\":\n   main()\n</code></pre>"},{"location":"classes-excercise/#enums","title":"Enums","text":"<pre><code>from enum import Enum\n\nclass TrafficLight(Enum):\n    # Set values to duration: RED = 30, YELLOW = 5, GREEN = 25\n    RED = 30\n    YELLOW = 5\n    GREEN = 25\n\n    def next(self) -&gt; \"TrafficLight\":\n        # Return next light: RED-&gt;GREEN, GREEN-&gt;YELLOW, YELLOW-&gt;RED\n        if self.value == 30:\n           return TrafficLight.GREEN\n        elif self.value == 25:\n            return TrafficLight.YELLOW\n        return TrafficLight.RED\n\n    def display(self) -&gt; None:\n        # Print: \"COLOR (Xs)\" e.g. \"RED (30s)\"\n        print(f'{self.name} ({self.value}s)')\n\n\nclass HttpStatus(Enum):\n    # Set values to (code, message) tuples:\n    # OK = (200, \"OK\"), BAD_REQUEST = (400, \"Bad Request\"),\n    # NOT_FOUND = (404, \"Not Found\"), INTERNAL_SERVER_ERROR = (500, \"Internal Server Error\")\n    OK = (200, \"OK\")\n    BAD_REQUEST = (400, \"Bad  Request\")\n    NOT_FOUND = (404, \"Not Found\")\n    INTERNAL_SERVER_ERROR = (500, \"Internal Server Error\")\n\n    def __init__(self, code: int, message: str):\n        self.code = code\n        self.message = message\n\n    def is_success(self) -&gt; bool:\n        # Return True if code &lt; 400\n        if self.code &lt; 400:\n            return True\n        return False\n\n    def display(self) -&gt; None:\n        # Print: \"CODE MESSAGE\" e.g. \"200 OK\"\n        print(f'{self.code} {self.message}')\n\n    @staticmethod\n    def from_code(code: int):\n        # Return the HttpStatus matching the code, or None if not found\n        if code == 200:\n            return HttpStatus.OK\n        elif code == 400:\n            return HttpStatus.BAD_REQUEST\n        elif code == 404:\n            return HttpStatus.NOT_FOUND\n        elif code == 500:\n            return HttpStatus.INTERNAL_SERVER_ERROR\n        return None\n\n\nif __name__ == \"__main__\":\n    HttpStatus.OK.display()\n    HttpStatus.NOT_FOUND.display()\n\n    print(f\"Is 200 success? {str(HttpStatus.OK.is_success()).lower()}\")\n    print(f\"Is 404 success? {str(HttpStatus.NOT_FOUND.is_success()).lower()}\")\n\n    found = HttpStatus.from_code(500)\n    if found is not None:\n        print(\"Found by code 500: \", end=\"\")\n        found.display()\n\n\n    light = TrafficLight.RED\n    for _ in range(6):\n        light.display()\n        light = light.next()\n</code></pre>"},{"location":"classes-excercise/#interfaces","title":"Interfaces","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass Formatter(ABC):\n    @abstractmethod\n    def format(self, message: str) -&gt; str:\n        pass\n\nclass PlainFormatter(Formatter):\n    def format(self, message: str) -&gt; str:\n        return message\n\nclass JsonFormatter(Formatter):\n    def format(self, message: str) -&gt; str:\n        return '{\"log\": \"' + message + '\"}'\n\nclass Logger:\n    def __init__(self, formatter: Formatter):\n        self._formatter = formatter\n\n    def log(self, message: str) -&gt; None:\n        print(self._formatter.format(message))\n\n\n\nclass Validator(ABC):\n    @abstractmethod\n    def validate(self, input: str) -&gt; bool:\n        pass\n\nclass EmailValidator(Validator):\n    def validate(self, input: str) -&gt; bool:\n        # Return True if \"@\" in input\n        return '@' in input\n\nclass PasswordValidator(Validator):\n    def validate(self, input: str) -&gt; bool:\n        # Return True if len(input) &gt;= 8\n        return len(input) &gt;= 8\n\nclass RegistrationService:\n    def __init__(self, validators: list[Validator]):\n        self._validators = validators\n\n    def register(self, input: str) -&gt; None:\n        # Run all validators on input. If all pass, print \"input\" - PASSED\n        # If any fail, print \"input\" - FAILED\n        for validator in self._validators:\n            if not validator.validate(input):\n                print(f'\"{input}\" - FAILED')\n                return\n\n        print(f'\"{input}\" - PASSED')\n\n\n\nif __name__ == \"__main__\":\n    email_reg = RegistrationService([EmailValidator()])\n    email_reg.register(\"user@example.com\")  # Should pass\n    email_reg.register(\"invalid-email\")      # Should fail\n\n    pass_reg = RegistrationService([PasswordValidator()])\n    pass_reg.register(\"strongpassword\")  # Should pass\n    pass_reg.register(\"short\")            # Should fail\n\n    plain_logger = Logger(PlainFormatter())\n    plain_logger.log(\"Server started on port 8080\")\n\n    json_logger = Logger(JsonFormatter())\n    json_logger.log(\"Server started on port 8080\")\n</code></pre>"},{"location":"classes-excercise/#encapsulation","title":"Encapsulation","text":"<pre><code>class TemperatureSensor:\n    def __init__(self):\n        self._readings: list[float] = []\n\n    def add_reading(self, value: float) -&gt; None:\n        if -50 &lt;= value &lt;= 150:\n            self._readings.append(value)\n\n    def get_average(self) -&gt; float:\n        if not self._readings:\n            return 0.0\n        return round(sum(self._readings) / len(self._readings), 2)\n\n    def get_reading_count(self) -&gt; int:\n        return len(self._readings)\n\n    def get_readings(self) -&gt; list[float]:\n        return self._readings[::]\n\n    def is_same(self, copList:list) -&gt; bool:\n        return copList is self._readings\n\nclass ShoppingCart:\n    def __init__(self):\n        self._items: dict[str, float] = {}\n        self._discount_applied = False\n        self._is_checked_out = False\n\n    def add_item(self, name: str, price: float) -&gt; None:\n        # Add item to cart, but reject if already checked out\n        if not self._is_checked_out:\n            self._items[name] = price\n            return\n        print('Cannot modify a checked-out cart')\n\n    def apply_discount(self, code: str) -&gt; bool:\n        # If code is \"SAVE10\" and no discount applied yet and not checked out,\n        # mark discount as applied and return True. Otherwise return False.\n        if not self._discount_applied and not self._is_checked_out and code == 'SAVE10':\n            self._discount_applied = True\n            return True\n        return False\n\n    def get_total(self) -&gt; float:\n        # Sum all item prices. If discount was applied, subtract 10%.\n        total = 0\n        for item in self._items:\n            total += self._items[item]\n        precent10 = total * 0.1\n        if self._discount_applied:\n            total -= precent10\n        return round(total, 2)\n\n    def checkout(self) -&gt; None:\n        # Mark cart as checked out (only if it has items and isn't already checked out)\n        if not self._is_checked_out and len(self._items):\n            self._is_checked_out = True\n\n\nif __name__ == \"__main__\":\n    cart = ShoppingCart()\n    cart.add_item(\"Laptop\", 999.99)\n    cart.add_item(\"Mouse\", 29.99)\n\n    print(f\"Total: ${cart.get_total():.2f}\")                     # 1029.98\n\n    print(f\"Discount: {str(cart.apply_discount('SAVE10')).lower()}\")          # true\n    print(f\"Total: ${cart.get_total():.2f}\")                     # 926.98\n\n    print(f\"Discount: {str(cart.apply_discount('SAVE10')).lower()}\")          # false\n\n    cart.checkout()\n    cart.add_item(\"Keyboard\", 79.99)  # Should be rejected\n    print(f\"Total: ${cart.get_total():.2f}\")                     # 926.98\n\n    sensor = TemperatureSensor()\n    sensor.add_reading(22.5)\n    sensor.add_reading(23.1)\n    sensor.add_reading(200.0)  # Should be rejected\n    sensor.add_reading(-10.0)\n\n    print(f\"Count: {sensor.get_reading_count()}\")  # 3\n    print(f\"Average: {sensor.get_average()}\")       # 11.87\n\n    copyList = sensor.get_readings()\n\n    print(sensor.is_same(copyList))\n</code></pre>"},{"location":"classes-excercise/#inheritance","title":"Inheritance","text":"<pre><code>class BankAccount:\n    def __init__(self, owner_name: str, account_number: str, balance: float):\n        # TODO: initialize self._owner_name, self._account_number, and self._balance\n        self._owner_name = owner_name\n        self._account_number = account_number\n        self._balance = balance\n\n    def deposit(self, amount: float) -&gt; bool:\n        # TODO: add amount to balance if amount &gt; 0, return True if successful\n        return False\n\n    def withdraw(self, amount: float) -&gt; bool:\n        # TODO: subtract amount from balance if balance &gt;= amount, return True\n        return False\n\n    def display_account(self):\n        # TODO: print \"owner_name (account_number) | Balance: $balance\"\n        # Hint: use f\"${self._balance:.2f}\" for formatting\n        print(f\"{self._owner_name} ({self._account_number}) | Balance: ${self._balance:.2f}\")\n\n\nclass SavingsAccount(BankAccount):\n    def __init__(self, owner_name: str, account_number: str,\n                 balance: float, interest_rate: float):\n        super().__init__(owner_name, account_number, balance)\n        # TODO: initialize self._interest_rate\n        self._interest_rate = interest_rate\n\n    def withdraw(self, amount: float) -&gt; bool:\n        # TODO: only allow if (balance - amount) &gt;= 100\n        if(self._balance - amount) &gt;= 100:\n            self._balance -= amount\n            return True\n        return False\n\n    def apply_interest(self):\n        # TODO: add (balance * interest_rate / 100) to balance\n        self._balance += ((self._balance * self._interest_rate) / 100)\n\n\nclass CheckingAccount(BankAccount):\n    def __init__(self, owner_name: str, account_number: str,\n                 balance: float, overdraft_limit: float):\n        super().__init__(owner_name, account_number, balance)\n        # TODO: initialize self._overdraft_limit\n        self._overdraft_limit = overdraft_limit\n\n    def withdraw(self, amount: float) -&gt; bool:\n        # TODO: allow if (balance + overdraft_limit) &gt;= amount\n        if(self._balance + self._overdraft_limit) &gt;= amount:\n            self._balance -= amount\n            return True\n        return False\n\n\nimport math\n\n\nclass Shape:\n    def __init__(self, name: str):\n        self._name = name\n\n    def area(self) -&gt; float:\n        # TODO: return 0 by default\n        return 0\n\n    def perimeter(self) -&gt; float:\n        # TODO: return 0 by default\n        return 0\n\n    def describe(self):\n        # TODO: print \"Shape: name, Area: area, Perimeter: perimeter\"\n        # Hint: use f\"{value:.2f}\" for formatting\n        print(f\"Shape: {self._name}, Area: {self.area():.2f}, Perimeter: {self.perimeter():.2f}\")\n\n\nclass Circle(Shape):\n    def __init__(self, radius: float):\n        super().__init__(\"Circle\")\n        self._radius = radius\n        # TODO: initialize self._radius\n\n    def area(self) -&gt; float:\n        # TODO: return math.pi * radius * radius\n        return round(math.pi * (self._radius ** 2), 2)\n\n    def perimeter(self) -&gt; float:\n        # TODO: return 2 * math.pi * radius\n        return round(2 * math.pi * self._radius, 2)\n\nclass Rectangle(Shape):\n    def __init__(self, width: float, height: float):\n        super().__init__(\"Rectangle\")\n        self._width = width\n        self._height = height\n        # TODO: initialize self._width and self._height\n\n    def area(self) -&gt; float:\n        # TODO: return width * height\n        return round(self._width * self._height, 2)\n\n    def perimeter(self) -&gt; float:\n        # TODO: return 2 * (width + height)\n        return round(2 * (self._width + self._height), 2)\n\n\n\n\nif __name__ == \"__main__\":\n    savings = SavingsAccount(\"Alice\", \"SAV-001\", 1000, 2.0)\n    savings.display_account()\n    print(f\"Withdraw $950: {str(savings.withdraw(950)).lower()}\")\n    savings.apply_interest()\n    savings.display_account()\n\n    print()\n\n    checking = CheckingAccount(\"Bob\", \"CHK-002\", 500, 300)\n    checking.display_account()\n    print(f\"Withdraw $700: {str(checking.withdraw(700)).lower()}\")\n    checking.display_account()\n\n    circle = Circle(5.0)\n    circle.describe()\n\n    rect = Rectangle(4.0, 6.0)\n    rect.describe()\n</code></pre>"},{"location":"classes-excercise/#polymorphism","title":"Polymorphism","text":"<pre><code>from abc import ABC, abstractmethod\n\n\nclass Discount(ABC):\n    def __init__(self, label: str):\n        self._label = label\n\n    @abstractmethod\n    def apply(self, price: float) -&gt; float:\n        pass\n\n    def describe(self, original_price: float):\n        # TODO: call self.apply(original_price) and print:\n        #   \"label: $original_price -&gt; $discounted_price\"\n        # Hint: use f\"{value:.2f}\" for formatting\n        discount_price = self.apply(original_price)\n        print(f\"{self._label}: ${original_price} -&gt; ${discount_price:.2f}\")\n\n\nclass PercentageDiscount(Discount):\n    def __init__(self, percentage: float):\n        super().__init__(f\"{percentage:.1f}% off\")\n        # TODO: initialize self._percentage\n        self._percentage = percentage\n\n    def apply(self, price: float) -&gt; float:\n        # TODO: return price * (1 - percentage / 100)\n        return price * (1-self._percentage/100)\n\n\nclass FlatDiscount(Discount):\n    def __init__(self, amount: float):\n        super().__init__(f\"${amount:.1f} off\")\n        # TODO: initialize self._amount\n        self._amount = amount\n\n    def apply(self, price: float) -&gt; float:\n        # TODO: return max(price - amount, 0)\n        return max(price-self._amount, 0)\n\n\nclass BuyOneGetOneFree(Discount):\n    def __init__(self):\n        super().__init__(\"Buy 1 Get 1 Free\")\n\n    def apply(self, price: float) -&gt; float:\n        # TODO: return price / 2\n        return price / 2\n\n\nclass OrderProcessor:\n    def process_order(self, item_name: str, price: float, discount: Discount):\n        # TODO: print \"Item: item_name\" then call discount.describe(price)\n        print(f\"Item: {item_name}\")\n        discount.describe(price)\n\nfrom abc import ABC, abstractmethod\n\n\nclass Logger(ABC):\n    @abstractmethod\n    def log(self, level: str, message: str) -&gt; None:\n        pass\n\n    @abstractmethod\n    def get_destination(self) -&gt; str:\n        pass\n\n\nclass ConsoleLogger(Logger):\n    def log(self, level: str, message: str) -&gt; None:\n        # TODO: print \"[level] message\" to console\n        print(f\"[{level}] {message}\")\n\n    def get_destination(self) -&gt; str:\n        # TODO: return \"Console\"\n        return \"Console\"\n\n\nclass FileLogger(Logger):\n    def __init__(self, file_path: str):\n        # TODO: initialize self._file_path\n        self.file_path = file_path\n\n    def log(self, level: str, message: str) -&gt; None:\n        # TODO: print \"Writing to file_path: [level] message\"\n        print(f\"Writing to {self.file_path}: [{level}] {message}\")\n\n    def get_destination(self) -&gt; str:\n        # TODO: return \"File: file_path\"\n        return f\"File: {self.file_path}\"\n\n\nclass DatabaseLogger(Logger):\n    def __init__(self, table_name: str):\n        # TODO: initialize self._table_name\n        self._table_name = table_name\n\n    def log(self, level: str, message: str) -&gt; None:\n        # TODO: print \"INSERT INTO table_name: [level] message\"\n        print(f\"INSERT INTO {self._table_name}: [{level}] {message}\")\n\n    def get_destination(self) -&gt; str:\n        # TODO: return \"Database: table_name\"\n        return f\"Database: {self._table_name}\"\n\n\nclass Application:\n    def __init__(self, logger: Logger):\n        # TODO: initialize self._logger\n        self._logger = logger\n        pass\n\n    def run(self):\n        # TODO: log three messages with level \"INFO\":\n        #   \"Application starting...\"\n        #   \"Processing data...\"\n        #   \"Application shutting down.\"\n        self._logger.log('INFO', \"Application starting...\")\n        self._logger.log('INFO', \"Processing data...\")\n        self._logger.log('INFO',  \"Application shutting down.\")\n        pass\n\n\n\n\nif __name__ == \"__main__\":\n    processor = OrderProcessor()\n\n    processor.process_order(\"Laptop\", 999.99, PercentageDiscount(20))\n    processor.process_order(\"Headphones\", 49.99, FlatDiscount(15))\n    processor.process_order(\"Keyboard\", 79.98, BuyOneGetOneFree())\n\n    loggers = [\n        ConsoleLogger(),\n        FileLogger(\"/var/log/app.log\"),\n        DatabaseLogger(\"app_logs\"),\n    ]\n\n    for logger in loggers:\n        print(f\"--- Using {logger.get_destination()} ---\")\n        app = Application(logger)\n        app.run()\n        print()\n</code></pre>"},{"location":"classes/","title":"OOPS CORE","text":""},{"location":"classes/#class-basics","title":"Class Basics","text":"<pre><code>class Cake():\n    \"\"\"\n    A class is a template or blueprint which contains attributes(data) and behaviour (methods)\n    for an object. A class is not a object itself it just the template.\n\n    A object is an real world manifestation of an object, with all properties and behaviour.\n    \"\"\"\n    def __init__(self, milk, dough, sugar, eggs, water,flavour):\n        # attributes\n        self.milk = milk \n        self.dough = dough\n        self.sugar = sugar\n        self.eggs = eggs\n        self.water = water\n        self.flavour = flavour\n\n    # behaviour\n    def prepare(self):\n        print(f'Added all the ingredients in to a pan and mixed {self.flavour}')\n\n    def bake(self):\n        print(f'{self.flavour} cake is baking')\n\n\nchocolate =  Cake('1tr', '1kg','1kg','6','1tr','chocolate-esence')\nvanilla = Cake('1tr', '1kg','1kg','6','1tr','vanill-esence')\n\nchocolate.prepare()\nchocolate.bake()\n\nvanilla.prepare()\nvanilla.bake()\n</code></pre>"},{"location":"classes/#enums","title":"Enums","text":"<pre><code>from abc import ABC, abstractmethod\n\"\"\"\nAbstraction is the process of hiding complex internal implementation details and exposing only the relevant, high-level functionality to the outside world. It allows developers to focus on what an object does, rather than how it does it.\n\"\"\"\nclass Vehicle(ABC):\n\n    def __init__(self, model,engine):\n        self.model = model\n        self.engine = engine\n\n    @abstractmethod\n    def start(self):\n        pass\n\n    def stop(self):\n        print(f'Turning off {self.model}')\nclass Car(Vehicle):\n\n    def start(self):\n        print(\"Car is started\")\nclass Tractor(Vehicle):\n\n    def start(self):\n        print(\"Tractor is starting\")\n\ntractor = Tractor('massey fergusion', '241')\ncar = Car('Tata nexon', 'revtron 1.2')\ncar.start()\ncar.stop()\n</code></pre>"},{"location":"classes/#interfaces","title":"Interfaces","text":"<pre><code>\"\"\"\nThey define what a component should do, not how it should do it.\n\nAt its core, an interface is a contract: a list of methods that any implementing class must provide.\nIt specifies a set of behaviors that a class agrees to implement but leaves the details of those\nbehaviors up to each implementation.\n\nBenfits of Interfaces.\nServices were decoupled.\nservice is dependent on Interfaces rather than Implementing Classes, we can add more implementing classes with out\nmodifying the strucure.\n\n\"\"\"\n\nfrom abc  import ABC, abstractmethod\n\nclass PaymentSerive(ABC):\n\n    @abstractmethod\n    def process_payment(self):\n        pass\n\nclass phonepeProvider(PaymentSerive):\n    def __init__(self, processor_name):\n        self.processor_name = processor_name\n    def process_payment(self):\n        print(f'payment is processing through {self.processer_name}')\n\n\nclass razorPayProvider(PaymentSerive):\n    def __init__(self, processor_name):\n        self.processor_name = processor_name\n    def process_payment(self):\n        print('Initializing razor pay')\n        print(f'payment is processing through {self.processer_name}')\n        print('transcation succesfull')\n\nclass CheckOutservice():\n\n    def __init__(self, paymentprovider):\n        self.order = 'order'\n        self.__paymentprovider = paymentprovider\n\n    def processPayment(self):\n        self.__paymentprovider.process_payment()\n\nphonepe = phonepeProvider('phonepe')\nrazorpay = razorPayProvider('razorpay')\n\nchekcout1 = CheckOutservice(phonepe)\nchekcout1.processPayment()\nchekcout12 = CheckOutservice(razorpay)\nchekcout12.processPayment()\n</code></pre>"},{"location":"classes/#encapsulation","title":"Encapsulation","text":"<pre><code>class BankAccount:\n    \"\"\"\n    Encapsulation is one of the four foundational principles of object-oriented design. It is the practice of grouping data (variables) and behavior (methods) that operate on that data into a single unit (typically a class) and restricting direct access to the internal details of that class.\n\n    Encapsulation = Data Hiding + Controlled Access\n\n    Encapsulation focuses on how to protect and control access to data within a class. But what if we extend that idea. Not just hiding data, but also hiding complexity itself?\n\n    That's where Abstraction comes in.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.__amount = 0\n\n\n    def _getmoney(self) -&gt; float:\n        return f\"Balance: {self.__amount}\"\n\n    def _deposit(self, money:float) -&gt; None:\n        if money &lt;= 0:\n            raise ValueError('money should be positive')\n        self.__amount += money\n        print(\"Money deposit successfull:\", money)\n\n    def _withDraw(self, money:float) -&gt; None:\n        if money &lt;=0 :\n            raise ValueError(\"Money should be positive\")\n        elif money &gt; self.__amount:\n            raise ValueError('Insufficient Balance')\n        else:\n            self.__amount -= money\n            print(f'Money withdraw successfull:',money)\nclass Product:\n    def __init__(self, name: str, price: float):\n        self.__name = name\n        self.price = price  # Uses the property setter for validation\n\n    @property\n    def name(self) -&gt; str:\n        return self.__name\n\n    @property\n    def price(self) -&gt; float:\n        return self.__price\n\n    @price.setter\n    def price(self, value: float) -&gt; None:\n        if value &lt; 0:\n            raise ValueError(\"Price cannot be negative\")\n        self.__price = value\n\naccount = BankAccount()\naccount._deposit(1000)\n\nprint(account._getmoney())\naccount._withDraw(120)\nprint(account._getmoney())\n\n\nproduct = Product('MSI Katana', 1000)\n\nprint(product.price)\nproduct.price = 100\nprint(product.price)\n</code></pre>"},{"location":"classes/#inheritance","title":"Inheritance","text":"<pre><code>from datetime import datetime \nclass NotificationService:\n\n    \"\"\"\n    Inheritance applies when there is a clear is a relationship.\n\n    Inheritance allows to use all public methods and properties of the parent class, Inheritance is used to group common\n    logic at one place.\n    \"\"\"\n\n    def __init__(self, recipient, message):\n\n        self.recipient = recipient\n        self.message = message\n        self.timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def formatHeader(self):\n        return f\"{self.timestamp} To: {self.recipient}\"\n\n    def send(self):\n        header = self.formatHeader()\n        print('Sending Notification:', header)\n\nclass EmailService(NotificationService):\n\n    def __init__(self, recipient, message, subject):\n        super().__init__(recipient, message)\n        self.subject = subject\n\n    def send(self):\n        print(self.formatHeader())\n        print(self.subject)\n        print(self.message)\n        print('Email sent succesfully')\n\nclass SMSService(NotificationService):\n    MAX_LENGTH = 160\n    def __init__(self, recipient, message, phonenumber):\n        super().__init__(recipient, message)\n        self.phonenumber = phonenumber\n\n\n    def send(self):\n        print(self.formatHeader())\n        print(self.phonenumber)\n        smsbody = self.message[:-3] + '...' if len(self.message) &gt; self.MAX_LENGTH else self.message\n        print(smsbody)\n        print('SMS sent successfully')\n\n\nemailService = EmailService('lokesh.c@gmail.com', 'Offer Details',' We are excited to offer a job to you at google')\n\nemailService.send()\n\nsmsService = SMSService('Lokesh', 'Thank you for shopping at amazon, please find your order details at this link', 9876543210)\nsmsService.send()\n</code></pre>"},{"location":"classes/#polymorphism","title":"Polymorphism","text":"<pre><code>from datetime import datetime\nclass NotificationService:\n\n    \"\"\"\n    Inheritance applies when there is a clear is a relationship.\n\n    Inheritance allows to use all public methods and properties of the parent class, Inheritance is used to group common\n    logic at one place.\n\n    Polymorphism is achieved usinf inheritance, \n    polymorphism benefits:\n     - loose coupling\n     - easy to scale\n     - enhance fleixbility\n     - enhance extensibility\n\n    Two types\n    - method overloading\n    - method overriding\n\n    Can be chieved through interfaces, abstract classes.\n    \"\"\"\n\n    def __init__(self, recipient, message):\n\n        self.recipient = recipient\n        self.message = message\n        self.timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def formatHeader(self):\n        return f\"{self.timestamp} To: {self.recipient}\"\n\n    def send(self):\n        header = self.formatHeader()\n        print('Sending Notification:', header)\n\nclass EmailService(NotificationService):\n\n    def __init__(self, recipient, message, subject):\n        super().__init__(recipient, message)\n        self.subject = subject\n\n    def send(self):\n        print(self.formatHeader())\n        print(self.subject)\n        print(self.message)\n        print('Email sent succesfully')\n\nclass SMSService(NotificationService):\n    MAX_LENGTH = 160\n    def __init__(self, recipient, message, phonenumber):\n        super().__init__(recipient, message)\n        self.phonenumber = phonenumber\n\n\n    def send(self):\n        print(self.formatHeader())\n        print(self.phonenumber)\n        smsbody = self.message[:-3] + '...' if len(self.message) &gt; self.MAX_LENGTH else self.message\n        print(smsbody)\n        print('SMS sent successfully')\n\n\nemailService = EmailService('lokesh.c@gmail.com', 'Offer Details',' We are excited to offer a job to you at google')\n\nemailService.send()\n\nsmsService = SMSService('Lokesh', 'Thank you for shopping at amazon, please find your order details at this link', 9876543210)\nsmsService.send()\n</code></pre>"},{"location":"classrelationships-excercise/","title":"CLASS RELATIONSHIPS EXCERCISE","text":""},{"location":"classrelationships-excercise/#association","title":"Association","text":"<pre><code>class Instructor:\n    def __init__(self, name: str):\n        self.name = name\n        self.courses = []\n\n    def add_course(self, course):\n        # TODO: Add course to list and set self as the course's instructor\n        self.courses.append(course)\n        course.set_instructor(self)\n        pass\n\nclass Course:\n    def __init__(self, title: str):\n        self.title = title\n        self.instructor = None\n        self.students = []\n\n    def set_instructor(self, instructor):\n        # TODO: Set the instructor reference\n        self.instructor = instructor\n\n\n    def enroll_student(self, student):\n        # TODO: Add student to list and set self as the student's enrolled course\n        self.students.append(student)\n        student.set_enrolled_course(self)\n\n\nclass Student:\n    def __init__(self, name: str):\n        self.name = name\n        self.enrolled_course = None\n\n    def set_enrolled_course(self, course):\n        # TODO: Set the enrolled course reference\n        self.enrolled_course = course\n\n    def get_instructor_name(self) -&gt; str:\n        # TODO: Navigate through enrolled_course to get the instructor's name\n        # Return \"No instructor\" if course or instructor is None\n        if not self.enrolled_course:\n            return 'No instructor'\n        return self.enrolled_course.instructor.name\n\nclass Message:\n    def __init__(self, author, content: str, timestamp: str):\n        # TODO: Initialize fields\n        self.author = author\n        self.content = content\n        self.timestamp = timestamp\n\nclass User:\n    def __init__(self, name: str):\n        self.name = name\n        self.followers = []\n        self.following = []\n        self.messages = []\n\n    def follow(self, user):\n        # TODO: Add user to following, add self to user's followers\n        # Guard against: self-follows, duplicates\n        if user != self and self not in user.followers and user not in self.following:\n            self.following.append(user)\n            user.followers.append(self)\n\n    def send_message(self, content: str, timestamp: str):\n        # TODO: Create Message and add to messages list\n        message = Message(self.name, content, timestamp)\n        self.messages.append(message)\n\nif __name__ == \"__main__\":\n    alice = User(\"Alice\")\n    bob = User(\"Bob\")\n    charlie = User(\"Charlie\")\n\n    alice.follow(bob)\n    alice.follow(charlie)\n    bob.follow(alice)\n\n    alice.send_message(\"Hello world!\", \"10:00 AM\")\n    bob.send_message(\"Learning OOP!\", \"10:30 AM\")\n\n    print(f\"{alice.name} is following:\")\n    for u in alice.following:\n        print(f\"  - {u.name}\")\n\n    print(f\"{bob.name}'s followers:\")\n    for u in bob.followers:\n        print(f\"  - {u.name}\")\n\n    print(f\"{alice.name}'s messages:\")\n    for m in alice.messages:\n        print(f\"  [{m.timestamp}] {m.content}\")\n\n    alice = Instructor(\"Alice\")\n    dsa = Course(\"Data Structures\")\n    sys_design = Course(\"System Design\")\n\n    alice.add_course(dsa)\n    alice.add_course(sys_design)\n\n    bob = Student(\"Bob\")\n    charlie = Student(\"Charlie\")\n\n    dsa.enroll_student(bob)\n    dsa.enroll_student(charlie)\n    sys_design.enroll_student(charlie)\n\n    print(f\"{alice.name}'s courses:\")\n    for c in alice.courses:\n        print(f\"  - {c.title}\")\n\n    print(f\"Students in {dsa.title}:\")\n    for s in dsa.students:\n        print(f\"  - {s.name}\")\n\n    print(f\"{bob.name}'s instructor: {bob.get_instructor_name()}\")\n</code></pre>"},{"location":"classrelationships-excercise/#aggregation","title":"Aggregation","text":"<pre><code>class Product:\n    def __init__(self, name: str, price: float):\n        self.name = name\n        self.price = price\n\nclass Catalog:\n    def __init__(self):\n        self.products = []\n\n    def add_product(self, product: Product):\n        # TODO: Add product to catalog\n        self.products.append(product)\n\n    def find_by_name(self, name: str):\n        # TODO: Find and return product by name, return None if not found\n        for product in self.products:\n            if product.name == name:\n                return product\n        return None\n\n    def get_product_count(self):\n        return len(self.products)\n\nclass Cart:\n    def __init__(self):\n        self.items = []\n\n    def add_item(self, product: Product):\n        # TODO: Add product to cart\n        self.items.append(product)\n\n    def clear_cart(self):\n        # TODO: Remove all items (don't destroy the products!)\n        self.items = []\n\n    def get_total(self):\n        # TODO: Sum prices of all items\n        total = 0\n        for product in self.items:\n            total += product.price\n        return total\n\n    def get_item_count(self):\n        return len(self.items)\n\nclass Customer:\n    def __init__(self, name: str, cart: Cart):\n        self.name = name\n        self.cart = cart\n\n    def checkout(self):\n        # TODO: Print cart items and total, then clear cart\n        print(f'{self.name} checking out:')\n        for p in self.cart.items:\n            print(f\"  - {p.name}: ${p.price}\")\n        print(f\"  Total: ${self.cart.get_total()}\")\n        self.cart.clear_cart()\n\nclass Employee:\n    def __init__(self, name: str, role: str):\n        self.name = name\n        self.role = role\n        self.teams = []\n\n    def add_team(self, team):\n        # TODO: Add team to employee's team list\n        self.teams.append(team)\n\n    def remove_team(self, team):\n        # TODO: Remove team from employee's team list\n        self.teams.remove(team)\n\n    def get_team_names(self):\n        # TODO: Return list of team names this employee belongs to\n        out = []\n        for team in self.teams:\n            out.append(team.name)\n        return out\n\nclass Team:\n    def __init__(self, name: str):\n        self.name = name\n        self.members = []\n\n    def add_member(self, employee: Employee):\n        # TODO: Add employee to team and register this team on the employee\n        self.members.append(employee)\n        employee.add_team(self)\n\n    def dissolve(self):\n        # TODO: Remove all members, don't destroy employees\n        for member in self.members:\n            member.teams.remove(self)\n        self.members = []\n\n    def get_member_count(self):\n        return len(self.members)\n\nclass Company:\n    def __init__(self, name: str):\n        self.name = name\n        self.employees = []\n        self.teams = []\n\n    def add_employee(self, employee: Employee):\n        # TODO: Add employee to company\n        self.employees.append(employee)\n\n    def add_team(self, team: Team):\n        # TODO: Add team to company\n        self.teams.append(team)\n\n    def dissolve_team(self, team: Team):\n        # TODO: Dissolve the team and remove it from the company's team list\n        team.dissolve()\n        self.teams.remove(team)\n\n    def get_employee_count(self):\n        return len(self.employees)\n\n    def get_team_count(self):\n        return len(self.teams)\n\nif __name__ == \"__main__\":\n    company = Company(\"TechCorp\")\n\n    alice = Employee(\"Alice\", \"Engineer\")\n    bob = Employee(\"Bob\", \"Designer\")\n    charlie = Employee(\"Charlie\", \"Engineer\")\n\n    company.add_employee(alice)\n    company.add_employee(bob)\n    company.add_employee(charlie)\n\n    backend = Team(\"Backend\")\n    frontend = Team(\"Frontend\")\n\n    company.add_team(backend)\n    company.add_team(frontend)\n\n    backend.add_member(alice)\n    backend.add_member(charlie)\n    frontend.add_member(alice)\n    frontend.add_member(bob)\n\n    print(\"Before dissolving:\")\n    print(f\"  {alice.name}'s teams: [{', '.join(alice.get_team_names())}]\")\n    print(f\"  Backend has {backend.get_member_count()} members\")\n    print(f\"  Company has {company.get_team_count()} teams, {company.get_employee_count()} employees\")\n\n    company.dissolve_team(backend)\n\n    print(\"\\nAfter dissolving Backend:\")\n    print(f\"  {alice.name}'s teams: [{', '.join(alice.get_team_names())}]\")\n    print(f\"  {charlie.name}'s teams: [{', '.join(charlie.get_team_names())}]\")\n    print(f\"  Company has {company.get_team_count()} teams, {company.get_employee_count()} employees\")\n    print(f\"  {alice.name} still exists: {alice.role}\")\n\n    laptop = Product(\"Laptop\", 999.99)\n    mouse = Product(\"Mouse\", 29.99)\n    keyboard = Product(\"Keyboard\", 79.99)\n\n    catalog = Catalog()\n    catalog.add_product(laptop)\n    catalog.add_product(mouse)\n    catalog.add_product(keyboard)\n\n    cart1 = Cart()\n    cart2 = Cart()\n\n    alice = Customer(\"Alice\", cart1)\n    bob = Customer(\"Bob\", cart2)\n\n    cart1.add_item(laptop)\n    cart1.add_item(mouse)\n    cart2.add_item(laptop)\n    cart2.add_item(keyboard)\n\n    print(f\"Alice's cart: {cart1.get_item_count()} items, ${cart1.get_total()}\")\n    print(f\"Bob's cart: {cart2.get_item_count()} items, ${cart2.get_total()}\")\n\n    alice.checkout()\n\n    print(f\"Catalog still has {catalog.get_product_count()} products\")\n    print(f\"Bob's cart still has {cart2.get_item_count()} items\")\n    print(f\"Laptop still exists: {laptop.name}\")\n</code></pre>"},{"location":"classrelationships-excercise/#composition","title":"Composition","text":"<pre><code>class CPU:\n    def __init__(self, model, cores):\n        self.model = model\n        self.cores = cores\n\n    def describe(self):\n        # TODO: Print CPU model and core count\n        print(f'  CPU: {self.model} ({self.cores} cores)')\n\nclass RAM:\n    def __init__(self, size_gb):\n        self.size_gb = size_gb\n\n    def describe(self):\n        # TODO: Print RAM size\n        print(f\"  RAM: {self.size_gb} GB\")\n\nclass HardDrive:\n    def __init__(self, capacity_gb):\n        self.capacity_gb = capacity_gb\n\n    def describe(self):\n        # TODO: Print hard drive capacity\n        print(f\"  Storage: {self.capacity_gb} GB\")\n\nclass Computer:\n    def __init__(self, name, cpu_model, cpu_cores, ram_gb, storage_gb):\n        self.name = name\n        # TODO: Create CPU, RAM, and HardDrive internally\n        self.cpu = CPU(cpu_model, cpu_cores)\n        self.ram = RAM(ram_gb)\n        self.hard_drive = HardDrive(storage_gb)\n\n    def describe_specs(self):\n        # TODO: Print computer name and describe all components\n        print(f'Computer: {self.name}')\n        self.cpu.describe()\n        self.ram.describe()\n        self.hard_drive.describe()\n\n    def upgrade_ram(self, new_size_gb):\n        # TODO (Challenge): Replace RAM with a higher-capacity one\n        self.ram = RAM(new_size_gb)\n\nimport time\n\nclass Message:\n    def __init__(self, sender, text):\n        self.sender = sender\n        self.text = text\n        self.timestamp = time.time()\n\n    def display(self):\n        # TODO: Print message in format \"[sender]: text\"\n        print(f'[{self.sender}]: {self.text}')\n\nclass Conversation:\n    def __init__(self, title):\n        self.title = title\n        self.messages = []\n\n    def send_message(self, sender, text):\n        # TODO: Create a Message internally and add it to the list\n        message = Message(sender, text)\n        self.messages.append(message)\n    def print_history(self):\n        # TODO: Print conversation title and all messages\n        print(f'--- {self.title} ---')\n        for message in self.messages:\n            message.display()\n\n    def delete(self):\n        # TODO: Clear all messages (they are destroyed with the conversation)\n        self.messages = []\n\n    def get_message_count(self):\n        return len(self.messages)\n\n    def forward_message(self, target, message_index):\n        # TODO (Challenge): Copy message content into a NEW Message\n        # in the target conversation. Don't move the original.\n        message = self.messages[message_index:message_index+1]\n        target.messages.append(message[0])\n\nif __name__ == \"__main__\":\n    team_chat = Conversation(\"Team Discussion\")\n    project_chat = Conversation(\"Project Alpha\")\n\n    team_chat.send_message(\"Alice\", \"Hey team, standup in 5 minutes\")\n    team_chat.send_message(\"Bob\", \"Got it, joining now\")\n    team_chat.send_message(\"Alice\", \"Don't forget to update your tasks\")\n\n    project_chat.send_message(\"Charlie\", \"Deployment is scheduled for Friday\")\n\n    print(\"Before deletion:\")\n    team_chat.print_history()\n    print(f\"Project chat has {project_chat.get_message_count()} messages\\n\")\n\n    # Challenge: forward a message\n    team_chat.forward_message(project_chat, 2)\n    print(\"After forwarding:\")\n    project_chat.print_history()\n\n    # Delete team chat - all its messages are destroyed\n    team_chat.delete()\n    print(\"\\nAfter deleting team chat:\")\n    print(f\"Team chat has {team_chat.get_message_count()} messages\")\n    print(f\"Project chat still has {project_chat.get_message_count()} messages\")\n\n    pc = Computer(\"Dev Workstation\", \"Intel i7-13700K\", 16, 32, 1000)\n\n    pc.describe_specs()\n\n    # Challenge: upgrade RAM and verify\n    pc.upgrade_ram(64)\n    print(\"\\nAfter RAM upgrade:\")\n    pc.describe_specs()\n\n    # When pc is destroyed, all components are destroyed with it.\n</code></pre>"},{"location":"classrelationships-excercise/#dependency","title":"Dependency","text":"<pre><code>class FileReader:\n    def read(self, file_path):\n        # TODO: Simulate reading a file and return its content\n        return f\"{file_path}\"\n\nclass FormatParser:\n    def parse(self, content, target_format):\n        # TODO: Simulate converting content to the target format\n        print(f'converting to target format: {target_format}')\n        return content\n\nclass FileWriter:\n    def write(self, file_path, content):\n        # TODO: Simulate writing content to a file\n        print(f'writing to a file: {file_path} with content: {content}')\n\nclass FileConverter:\n    def convert(self, source_path, target_path, target_format,\n                reader, parser, writer):\n        # TODO: Use reader to read, parser to parse, writer to write\n        # Print each step so you can verify the flow\n        content = reader.read(source_path)\n        content = parser.parse(content, target_format)\n        writer.write(target_path, content)\n\n\n\nclass InventoryChecker:\n    def check_stock(self, item_name, quantity):\n        # TODO: Simulate checking inventory\n        # Return True if available, False otherwise\n        if quantity &amp; 1 and item_name:\n            return True\n\n        return False\n\nclass PriceCalculator:\n    def calculate(self, item_name, quantity):\n        # TODO: Simulate calculating the price\n        return quantity * 100.0\n\nclass InvoiceGenerator:\n    def generate(self, item_name, quantity, total):\n        # TODO: Simulate generating an invoice string\n        return f\"Invoice for {item_name} - {quantity}: ${total}\"\n\nclass OrderProcessor:\n    def process_order(self, item_name, quantity, checker, calculator, generator):\n        # TODO: Check stock, calculate price, generate invoice\n        # Return the invoice string, or an error message if out of stock\n        if checker.check_stock(item_name, quantity):\n            price = calculator.calculate(item_name, quantity)\n            return generator.generate(item_name, quantity, price)\n        return ''\n\nif __name__ == \"__main__\":\n    processor = OrderProcessor()\n\n    checker = InventoryChecker()\n    calculator = PriceCalculator()\n    generator = InvoiceGenerator()\n\n    invoice = processor.process_order(\"Laptop\", 3, checker, calculator, generator)\n    print(invoice)\n\n    converter = FileConverter()\n\n    reader = FileReader()\n    parser = FormatParser()\n    writer = FileWriter()\n\n    converter.convert(\"data.csv\", \"output.json\", \"JSON\", reader, parser, writer)\n</code></pre>"},{"location":"classrelationships-excercise/#realization","title":"Realization","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass Plugin(ABC):\n    @abstractmethod\n    def execute(self, text):\n        pass\n\n    @abstractmethod\n    def get_name(self):\n        pass\n\nclass SpellCheckPlugin(Plugin):\n    def execute(self, text):\n        text = text.replace('teh', 'the')\n        text = text.replace('adn', 'and')\n        return text  # TODO: replace \"teh\" with \"the\", \"adn\" with \"and\"\n\n    def get_name(self):\n        return \"Spell Check\"\n\nclass WordCountPlugin(Plugin):\n    def execute(self, text):\n        temp = text.split()\n        text += f'\\n[Word Count: {len(temp)}]'\n        return text  # TODO: append \"\\n[Word count: X]\" to the text\n\n    def get_name(self):\n        return \"Word Count\"\n\nclass UpperCasePlugin(Plugin):\n    def execute(self, text):\n\n        return text.upper()  # TODO: return text.upper()\n\n    def get_name(self):\n        return \"Upper Case\"\n\nclass TextEditor:\n    def __init__(self):\n        self.plugins = []\n\n    def register_plugin(self, plugin):\n        # TODO: Add the plugin to the list and print \"Registered: [name]\"\n        self.plugins.append(plugin)\n        print(f'Registered: {plugin.get_name()}')\n\n    def run_plugins(self, text):\n        # TODO: Run each plugin in sequence, passing output of one as input to the next\n        # Print \"Running: [name]\" before each plugin\n        # Return the final processed text\n        for plugin in self.plugins:\n            print(f'Running: {plugin.get_name()}')\n            text = plugin.execute(text)\n        return text\nfrom abc import ABC, abstractmethod\nimport math\n\nclass Drawable(ABC):\n    @abstractmethod\n    def draw(self):\n        pass\n\n    @abstractmethod\n    def get_area(self):\n        pass\n\nclass Circle(Drawable):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def draw(self):\n        print(f'Drawing circle with radius {self.radius}')\n         # TODO: print \"Drawing circle with radius X\"\n\n    def get_area(self):\n        return math.pi * self.radius ** 2\n          # TODO: return \u03c0 * r\u00b2\n\nclass Rectangle(Drawable):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def draw(self):\n        print(f'Drawing rectangle {self.width}x{self.height}')\n         # TODO: print \"Drawing rectangle WxH\"\n\n    def get_area(self):\n        return self.width * self.height\n        return 0  # TODO: return width * height\n\nclass Triangle(Drawable):\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n\n    def draw(self):\n        print(f\"Drawing triangle with base {self.base} and height {self.height}\")\n        pass  # TODO: print \"Drawing triangle with base B and height H\"\n\n    def get_area(self):\n        return 0.5 * self.base * self.height\n         # TODO: return 0.5 * base * height\n\nclass Canvas:\n    def draw_all(self, shapes):\n        # TODO: For each shape, call draw() and print its area\n        for shape in shapes:\n            shape.draw()\n            print(f'  Area: {shape.get_area():.2f}\\n')\n\nif __name__ == \"__main__\":\n    canvas = Canvas()\n\n    shapes = [\n        Circle(5.0),\n        Rectangle(4.0, 6.0),\n        Triangle(3.0, 8.0),\n    ]\n\n    canvas.draw_all(shapes)\n\n    editor = TextEditor()\n    editor.register_plugin(SpellCheckPlugin())\n    editor.register_plugin(WordCountPlugin())\n\n    result = editor.run_plugins(\"teh quick brown fox adn teh lazy dog\")\n    print(f\"\\nFinal output: {result}\")\n</code></pre>"},{"location":"classrelationships/","title":"CLASS RELATIONSHIPS","text":""},{"location":"classrelationships/#association","title":"Association","text":"<pre><code>\"\"\"\nAssociation: Assocatiation represents a relationship when an object needs\n to know about the exisistence of other object to perform its responsibilities.\n\nA doctor has patients\nA driver has car\nA student enroll in courses\n\nIf A class must communicate with another class B to fullfill its purpose,\nthen class A is associated with class B.\n\nIn an association\nBoth classes can existly independently\nTheir lifecycle doesn't depend on each other.\n\nAssociation reflects a has-a or uses-a relationship.\n\nIt is indicated  with a straightline --------, and error is used for direction -&gt;\nNo error indicated bidirectional.\n\nThe levels of association\n1 to 1\no to 1\n1 to *\n*\n\"\"\"\n\n\nclass CheckoutService:\n\n    def __init__(self, payment_gateway):\n        self._payment_gateway = payment_gateway\n\n    def pay(self):\n        self._payment_gateway.pay()\n\n\nclass PaymentService:\n\n    def __init__(self, name):\n        self._name = name\n\n    def pay(self):\n        print('I am procesing payment')\n\n\n# here the relationship between checkout service to payment service 1 to 0, \n# checkout service references the payment service where as the payment\n# service doesn't need to know about the existence of checkoutservice\n\n\nclass Profle:\n\n    def __init__(self):\n        self.user = None\n\n    def set_user(self, user):\n        self.user = user\n\nclass User:\n\n    def __init__(self):\n        self.profile =  None\n\n    def set_profile(self, profile):\n\n        self.profile = profile\n        profile.set_user(self)\n\n\n# for a many to one relationship think of a project and issues, \n# every issue is assocaited with one project, but one project \n# may have multiple issues.\n\n\n# for a many to many relationship think of whatsapp groups \n# where each user can be in many groups and each group \n# can have many users.\n\n\n\n# Hospital Appointment System\n\n\nclass Room:\n\n    def __init__(self, roomno):\n        self.roomno = roomno\n\n\n\nclass Doctor:\n\n    def __init__(self, name, specialization):\n        self.name = name\n        self.specialization = specialization\n        self.appointments = []\n\n    def add_appointment(self, appointment):\n        self.appointments.append(appointment)\n\n    def get_patients(self):\n        seen = set()\n        result = []\n        for appointment in self.appointments:\n            if id(appointment.patient) not in seen:\n                seen.add(id(appointment.patient))\n                result.append(appointment.patient)\n        return result\n\nclass Patient:\n\n    def __init__(self, name):\n        self.name = name\n        self.appointments = []\n\n    def book_appointment(self, appointment):\n        self.appointments.append(appointment)\n\n    def get_doctors(self):\n        seen = set()\n        result = []\n        for appointment in self.appointments:\n            if id(appointment.doctor) not in seen:\n                seen.add(id(appointment.doctor))\n                result.append(appointment.doctor)\n        return result\n\nclass Appointment:\n\n    def __init__(self,  doctor:Doctor, patient:Patient,room,time:str,):\n        self.room = room\n        self.doctor = doctor\n        self.patient = patient\n        self.time = time\n        doctor.add_appointment(self)\n        patient.book_appointment(self)\n\n\ndr_smith = Doctor(\"Dr. Smith\", \"Cardiology\")\ndr_patel = Doctor(\"Dr. Patel\", \"Neurology\")\n\nalice = Patient(\"Alice\")\nbob = Patient(\"Bob\")\n\nroom_101 = Room(\"101\")\nroom_205 = Room(\"205\")\n\nAppointment(dr_smith, alice, room_101, \"9:00 AM\")\nAppointment(dr_smith, bob, room_101, \"10:00 AM\")\nAppointment(dr_patel, alice, room_205, \"2:00 PM\")\n\nprint(f\"{dr_smith.name}'s patients:\")\nfor p in dr_smith.get_patients():\n    print(f\"  - {p.name}\")\n\nprint(f\"{alice.name}'s doctors:\")\nfor d in alice.get_doctors():\n    print(f\"  - {d.name} ({d.specialization})\")\n\nprint(f\"{dr_smith.name}'s schedule:\")\nfor a in dr_smith.appointments:\n    print(f\"  - {a.time} with {a.patient.name} in Room {a.room.roomno}\")\n</code></pre>"},{"location":"classrelationships/#aggregation","title":"Aggregation","text":"<pre><code>\"\"\"\nAggregration is a specalized form of association with the whole and part relationships.\n\nThe whole and part are logically connnected through a container-contained heirarchy\nThe part can exists independently of the whole\nThe whole doesnt create or destroy part\n\nAggreagration is denoted with a solid line with a diamond diamond on the whole side.\n\n\"\"\"\n\nclass Professor:\n\n    def __init__(self, name:str, specialization:str) -&gt; None:\n        self.name = name\n        self.specialization = specialization\n\n\nclass Department:\n\n    def __init__(self, department_name:str, professors:list[Professor]) -&gt; None:\n        self.department_name = department_name\n        self.professors = professors\n\n\n    def add_professor(self, professor:Professor):\n        self.professors.append(professor)\n\n    def remove_professor(self, professor:Professor):\n        self.professors.remove(professor)\n\n\n\nprofessor1 = Professor('Sastry', 'Data Structures')\nprofessor2 = Professor('Ratna Kumari', 'Compiler Design')\nprofessor3 = Professor('harinadha', 'Algorithms')\n\nprofessors = [professor1, professor2, professor3]\n\n\ncsDept = Department('CSE', professors=professors)\n\n\n# Aggregation promoted reusability (payment microservices acorss different projects)\n# Improved Flexibility\n# Reflects real world relationship\n\n\n\n# Music Library System\n\n\nclass Artist:\n\n    def __init__(self, name:str) -&gt; None:\n        self.name = name\n\n\nclass Song:\n\n    def __init__(self, name, artist:Artist, duration:int) -&gt; None:\n        self.name = name\n        self.artist = artist\n        self.duration = duration\n\n\nclass Library:\n\n    def __init__(self) -&gt; None:\n        self.library = []\n\n    def add_song(self, song) -&gt; None:\n        self.library.append(song)\n\n\nclass User:\n\n    def __init__(self, name):\n        self.name = name\n        self.playlists = []\n\n\n    def add_playlist(self, playlist):\n        self.playlists.append(playlist)\n\n    def remove_playlist(self, playlist):\n        self.playlists.remove(playlist)\n\nclass Playlist:\n\n    def __init__(self, name):\n        self.name = name\n        self.songs = []\n\n\n    def add_song(self, song):\n        self.songs.append(song)\n\n    def remove_song(self, song):\n        self.songs.remove(song)\n</code></pre>"},{"location":"classrelationships/#composition","title":"Composition","text":"<pre><code>\"\"\"\nWhat if the relationship is so strong, that the part cannot exists without the whole,\nThis is the world of composition which is a strong form of association, where the\nwhole owns the lifecycle of the part.\n\nConsider order and lineitems , lineitems can't exist without the order, if order\ndestroys lineitems also goes with it.\n\nWhen to use composition:\n - is the part meaningless without whole\n - should the whole controls the lifecycle of the part\n - are the parts exclusive to one whole\n - do you want to model strong containment\n\nIt is represented with a diamond on the whole\n\n\"\"\"\n\n\nclass LineItem:\n    def __init__(self, product_name, quantity, unit_price):\n        self.product_name = product_name\n        self.quantity = quantity\n        self.unit_price = unit_price\n\n    def get_subtotal(self):\n        return self.quantity * self.unit_price\n\n    def describe(self):\n        print(f\"{self.product_name} x{self.quantity} \"\n              f\"@ ${self.unit_price:.2f} = ${self.get_subtotal():.2f}\")\n\nclass Order:\n    def __init__(self, order_id):\n        self.order_id = order_id\n        self.line_items = []\n\n    def add_item(self, product, quantity, unit_price):\n        self.line_items.append(LineItem(product, quantity, unit_price))\n\n    def remove_item(self, product):\n        self.line_items = [\n            item for item in self.line_items\n            if item.product_name != product\n        ]\n\n    def get_total(self):\n        return sum(item.get_subtotal() for item in self.line_items)\n\n    def print_receipt(self):\n        print(f\"Order: {self.order_id}\")\n        for item in self.line_items:\n            item.describe()\n        print(f\"Total: ${self.get_total():.2f}\")\n\nif __name__ == \"__main__\":\n    order = Order(\"ORD-1001\")\n    order.add_item(\"Wireless Mouse\", 2, 29.99)\n    order.add_item(\"USB-C Cable\", 3, 9.99)\n    order.add_item(\"Laptop Stand\", 1, 49.99)\n\n    order.print_receipt()\n\n    # When order is deleted, all LineItems are destroyed with it.\n    # No LineItem exists outside of an Order.\n</code></pre>"},{"location":"classrelationships/#dependency","title":"Dependency","text":"<pre><code>\"\"\"\nWhat happens when a class needs to use another class for a brief moment to get a job\ndone, without needing to hold on to it forever.\n\nThat's dependency. It represents the weakest form of relationship between classes.\n\nA dependency exists when one class relies on another class to fullfill a responsibility,\nbut does so without retaining a reference to it.\n\nA class accepts another class as a method parameter.\nA class instantiates or uses another class inside a method.\nA class returns an object of another class from a method.\n\nKey charactheristics:\n- short lived\n- no ownership\n\"uses-a\" relationship\n\n\nIt is represented with dotted line and arrow from dependent class to the class it depends.\n\n\"\"\"\n\n\nclass Document:\n    def __init__(self, content):\n        self.content = content\n\n    def get_content(self):\n        return self.content\n\nclass Printer:\n    def print(self, document):\n        print(\"Printing:\", document.get_content())\n\nif __name__ == \"__main__\":\n    doc = Document(\"Hello, World!\")\n    printer = Printer()\n\n    printer.print(doc)\n\n    # After print() returns, the printer has no reference to the document.\n    # The document can be garbage collected independently of the printer.               \n\n\n\n# Event Booking System\nclass SeatValidator:\n    def is_available(self, event_id, seat_number):\n        print(f\"Checking seat {seat_number} for event {event_id}\")\n        return True  # Simulated: seat is available\n\nclass PaymentProcessor:\n    def charge(self, email, amount):\n        print(f\"Charging ${amount} to {email}\")\n        return True  # Simulated: payment succeeds\n\nclass QRCodeGenerator:\n    def generate(self, event_id, seat_number):\n        qr_code = f\"QR-{event_id}-{seat_number}\"\n        print(f\"Generated QR code: {qr_code}\")\n        return qr_code\n\nclass EmailService:\n    def send_confirmation(self, email, qr_code):\n        print(f\"Sending confirmation to {email} with code {qr_code}\")\n\nclass TicketBookingService:\n    def book_ticket(self, event_id, seat_number, email, amount,\n                    validator, payment, qr_generator, email_service):\n        if not validator.is_available(event_id, seat_number):\n            print(\"Seat not available.\")\n            return False\n\n        if not payment.charge(email, amount):\n            print(\"Payment failed.\")\n            return False\n\n        qr_code = qr_generator.generate(event_id, seat_number)\n        email_service.send_confirmation(email, qr_code)\n\n        print(\"Booking confirmed!\")\n        return True\n\nif __name__ == \"__main__\":\n    booking_service = TicketBookingService()\n\n    # All dependencies are created externally and passed in\n    validator = SeatValidator()\n    payment = PaymentProcessor()\n    qr_generator = QRCodeGenerator()\n    email_service = EmailService()\n\n    booking_service.book_ticket(\"CONF-2025\", \"A12\", \"alice@example.com\",\n        99.99, validator, payment, qr_generator, email_service)     \n</code></pre>"},{"location":"classrelationships/#realization","title":"Realization","text":"<pre><code>\"\"\"\nImplements a contract relationship\n\nThis is where realization comes in. It represents a relationship between interface and the \nimplementing class.\n\nRealization is an \"implements\" relationship where a class fulfills a contract defined by an interface.\n\nThe relationship works like this:\n - An interface defines what must be done(the contract)\n - A class implements how its done\n - The implementing class must provide all methods declared in the interface\n - Multiple classes can realize the same interface differently.\n\n It is represented using dashed line with a hallow triangle pointing to the interface.\n\n Realization vs Inheritance\n\nInheritance models identity\n\n - The child inherits everything from the parent, including state and behavior\n - Dog is an Animal\n\nRealization models capability\n - The implementing classes share what they are can do, not what they are. A bird and\n plane have nothing else in common.\n\n\n\"\"\"\n\nfrom abc import ABC, abstractmethod\n\nclass Flyable(ABC):\n    @abstractmethod\n    def fly(self):\n        pass\n\n    @abstractmethod\n    def get_flight_info(self):\n        pass\n\nclass Bird(Flyable):\n    def __init__(self, species, wing_span):\n        self.species = species\n        self.wing_span = wing_span\n\n    def fly(self):\n        print(f\"{self.species} flaps its wings and takes off.\")\n\n    def get_flight_info(self):\n        return f\"{self.species} (wingspan: {self.wing_span}m, powered by muscle)\"\n\n\nclass Airplane(Flyable):\n    def __init__(self, model, max_altitude):\n        self.model = model\n        self.max_altitude = max_altitude\n\n    def fly(self):\n        print(f\"{self.model} engines roar as it accelerates down the runway.\")\n\n    def get_flight_info(self):\n        return f\"{self.model} (max altitude: {self.max_altitude}ft, powered by jet engines)\"\n\n\nclass Drone(Flyable):\n    def __init__(self, battery_level, max_range):\n        self.battery_level = battery_level\n        self.max_range = max_range\n\n    def fly(self):\n        print(f\"Drone propellers spin up. Battery at {self.battery_level}%.\")\n\n    def get_flight_info(self):\n        return f\"Drone (range: {self.max_range}km, battery: {self.battery_level}%)\"\n\nif __name__ == \"__main__\":\n    flying_things = [\n        Bird(\"Eagle\", 2.3),\n        Airplane(\"Boeing 737\", 41000),\n        Drone(85, 10.0),\n    ]\n\n    for flyer in flying_things:\n        print(flyer.get_flight_info())\n        flyer.fly()\n        print()     \n</code></pre>"}]}